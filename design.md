# WOCO


WOCO已合并入原工程WILL，不再更新。

WOCO的主架构已经完成，细节尚未处理完毕（例如依据epoch调整学习率等）。

例如：Y=M*pool(conv(K, X))+b

为了使运算可以反向，每个矩阵除保存原数据外，还应保存用于反向的数据。

为使隐式生成计算图的操作可以成立，矩阵的数据必须是共享，即复制赋值相当于是一个别名。

表达式是C++，不是py！对象的内存释放时机遵循C++的规则，想节省内存中间变量就写成局部的，想快就写成相对全局的。想跨卡计算就在中间加复制。

为利用好C++的内存管理机制，对象计算必须可以成立。即不宜使用类似下面操作数均为指针的形式。

```cpp
Matrix * mul(Matrix*, Matrix*)
```
前向一次即可计算出顺序，反向时似乎内存分配需考虑。

在运算的时候，需保存一些全局信息。例如

```cpp
operator +(l, r)
{
    ...
    if(is computing graph)
    push(l,r,add) 这里保存到一个全局栈里，反向时逆序。此处需确保编译期展开，否则构造代价过大。
}


begin calc graph //clear stack
make structure
end calc graph // save stack as a queue
```

有可能需要两类算符。a=mul(l,r), mul(l,r,a)可能需要区分对待。因为要处理反向时内存的分配。

网络若以文本文件描述，可能需要语法解析，可以借用一些轻量语法库。

因为基于操作的计算流程不同，反向时必须多出一些运算（反向数据清零，不同路径的反向和等），加上不使用裸指针操作，故基本无法优化至基于层的的同样效果。

应使用一个网络类保存表达式，用户使用时，应继承这个类，使用一些虚函数。（似乎可以使用lambda，待查）通过虚函数的继承技术，网络可以用dll保存，似乎加密更方便了。

损失函数也应是一组矩阵操作，只是需要实现其加法和数乘。

求解器负责根据反向数据来更新权重的方法。考虑求解器内部的状态，至少应维护一个与权重相同维度的矩阵。

基本所有框架，包含woco前身，都将权重衰减作为求解器的一部分，woco将其视为损失函数的一部分，这样处理起来更加自然，符合数学上的写法。

请参考woco-mnist中的网络部分。
